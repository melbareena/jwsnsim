/*
 * Copyright (c) 2002, Vanderbilt University
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice, the following
 * two paragraphs and the author appear in all copies of this software.
 * 
 * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT
 * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 * Author: Gyorgy Balogh, Gabor Pap, Miklos Maroti
 * Date last modified: 02/09/04
 */
package sim.jprowler;

import sim.jprowler.clock.Clock;

/**
 * This class represents a mote and all its properties important from the
 * simulation point of view. The MAC layer specific constant are all defined and
 * used here.
 * 
 * @author Gyorgy Balogh, Gabor Pap, Miklos Maroti
 */
public class Mica2NodeNonCSMA extends Node {
	
	protected enum RadioStates{
		OFF, IDLE, WAKEUP, TRANSMITTING,RECEIVING
	}
	
	protected RadioStates radioState = RadioStates.IDLE;
	
	protected RadioListener listener = null;
	
	/**
	 * In this simulation not messages but references to motes are passed. All
	 * this means is that the Mica2Node has to hold the information on the
	 * sender application which runs on this very mote.
	 */
	protected Protocol senderApplication = null;

	 /**
	 * This node is the one that sent the last message or the one this node is
	 * receiving a message from right now. It is mainly used for display
	 purposes,
	 * as you know this information is not embedded into any TinyOS message.
	 */
	 protected Node senderNode = null;

	/**
	 * This is the message being sent, on reception it is extracted and the
	 * message part is forwarded to the appropriate application, see
	 * {@link Protocol#receiveMessage}.
	 */
	protected RadioPacket sentPacket = null;
	
	protected RadioPacket receivedPacket = null;

	// //////////////////////////////
	// STATE VARIABLES
	// //////////////////////////////

	/**
	 * State variable, true if radio is in sending mode, this means it has a one
	 * message long buffer, which is full and the Node is trying to transmit its
	 * content.
	 */

	/** State variable, true if the last received message got corrupted by noise */
	protected boolean corrupted = false;

	/** For CC2420 250 kbps -> approximately 32 microseconds per byte. */
	/** In TinyOS, default packet size is 11  byte header, 28 byte payload, 7 byte meta */
	/** 46 * 32 microsec = approximately 1.5 ms */
	public static int transmissionTime = 1500;

	// //////////////////////////////
	// EVENTS
	// //////////////////////////////
	/**
	 * Signals the end of a transmission.
	 */
	private EndTransmissionEvent endTransmissionEvent = new EndTransmissionEvent();

	// //////////////////////////////
	// Noise and signal
	// //////////////////////////////

	/** Signal stregth of transmitting or parent node. */
	private double signalStrength = 0;

	/** Noise generated by other nodes. */
	private double noiseStrength = 0;

	/**
	 * The constant self noise level. See either the {@link Mica2NodeNonCSMA#calcSNR}
	 * or the {@link Mica2NodeNonCSMA#isChannelFree} function.
	 */
	public double noiseVariance = 0.025;

	/**
	 * The maximum noise level that is allowed on sending. This is actually a
	 * multiplicator of the {@link Mica2NodeNonCSMA#noiseVariance}.
	 */
	public double maxAllowedNoiseOnSending = 5;

	/** The minimum signal to noise ratio required to spot a message in the air. */
	public double receivingStartSNR = 4.0;

	/**
	 * The maximum signal to noise ratio below which a message is marked
	 * corrupted.
	 */
	public double corruptionSNR = 2.0;
	
	public static final int wakeUpTime = 180; 
	public static final int processingTime = 180;
	
	private WakeUpEvent wakeUpEvent = new WakeUpEvent();

	/** The event signaled when the radio wake-up is ended **/
	class WakeUpEvent extends Event {
		/** The amount of time spent for waking up radio --- deterministic */
		
		
		public void execute() {

			switch (radioState) {

			case WAKEUP:
				radioState = RadioStates.IDLE;
				
				if(sentPacket != null){
					radioState = RadioStates.TRANSMITTING;
					processingEvent.register(processingTime);
				}
				
				break;

			default:
				break;
			}
		}
	}
	
	/** The event signaled when the radio wake-up is ended **/
	class SleepEvent extends Event {
		/** The amount of time spent for waking up radio --- deterministic */
		
		
		public void execute() {

			switch (radioState) {

			case IDLE:
				radioState = RadioStates.OFF;
				if(listener != null)
					listener.sleepTimerExpired();
				break;

			default:
				break;
			}
		}
	}

	private SleepEvent sleepEvent = new SleepEvent();
	
	private ProcessingEvent processingEvent = new ProcessingEvent();

	/** The event signaled when the radio wake-up is ended **/
	class ProcessingEvent extends Event {
		/** The amount of time spent for waking up radio --- deterministic */

		
		public void execute() {

			switch (radioState) {

			case TRANSMITTING:
				setEventTime(sentPacket);
				
				if(listener != null)
					listener.startedTransmitting();
				
				beginTransmission(1, Mica2NodeNonCSMA.this);
				endTransmissionEvent.register(transmissionTime);
				break;

			default:
				break;
			}
		}
		
		private void setEventTime(RadioPacket packet) {
			UInt32 age = getClock().getValue();
			age = age.subtract(packet.getEventTime());
			packet.setEventTime(age);		
		}
	}
	
	/**
	 * Inner class EndTransmissionEvent. Represents the end of a transmission.
	 */
	class EndTransmissionEvent extends Event {
		/**
		 * Removes the noise generated by the transmission and sets the state
		 * variables accordingly.
		 */
		public void execute() {
			radioState = RadioStates.IDLE;
			endTransmission();
			senderApplication.sendMessageDone(true);
			sentPacket = null;
			senderApplication = null;
			
			if(listener != null)
				listener.stoppedTransmitting();
			
			stats.startEpoch();
		}
	}
	
	/**
	 * Parameterized constructor, it set both the {@link Simulator} in which
	 * this mote exists and the {@link RadioModel} which is used by this mote.
	 * 
	 * @param sim
	 *            the Simulator in which the mote exists
	 * @param radioModel
	 *            the RadioModel used on this mote
	 */
	
	protected RadioStats stats;
	public Mica2NodeNonCSMA(int id, RadioModel radioModel,Clock clock) {
		super(radioModel,clock);
		setId(id);
		stats = new RadioStats(this);
		stats.on();
	}
	
	public void setListener(RadioListener listener){
		this.listener = listener;
	}

	/**
	 * Calls the {@link Mica2NodeNonCSMA#addNoise} method. See also
	 * {@link Node#receptionBegin} for more information.
	 */
	protected void receptionBegin(double strength, Object stream) {	
		addNoise(strength, stream);
	}

	/**
	 * Calls the {@link Mica2NodeNonCSMA#removeNoise} method. See also
	 * {@link Node#receptionEnd} for more information.
	 */
	protected void receptionEnd(double strength, Object stream) {	
		removeNoise(strength, stream);
	}

	/**
	 * Sends out a radio message if the radio is OFF or IDLE. If the radio
	 * is OFF, it wakes up and then sends.
	 */
	public boolean sendMessage(RadioPacket packet, Protocol app) {
		
		boolean success = true;
		
		switch(radioState){
		
		case IDLE:
			radioState = RadioStates.TRANSMITTING;
			processingEvent.register(processingTime);
			
			this.sentPacket = packet.clone();
			senderApplication = app;

			break;		
			
		case OFF:			
			this.sentPacket = packet.clone();
			senderApplication = app;
			wakeUp();
			break;
			
		default:
			success = false;
			break;
		
		}
		
		return success;
	}

	/**
	 * Tells if the transmitting media is free of transmissions based on the
	 * noise level.
	 * 
	 * @param signal
	 *            the signal strength
	 * @param noise
	 *            the noise level
	 * @return returns true if the message is corrupted
	 */
	public boolean isMessageCorrupted(double signal, double noise) {
		return calcSNR(signal, noise) < corruptionSNR;
	}

	/**
	 * Inner function for calculating the signal noise ratio the following way: <br>
	 * signal / (noiseVariance + noise).
	 * 
	 * @param signal
	 *            the signal strength
	 * @param noise
	 *            the noise level
	 * @return returns the SNR
	 */
	protected double calcSNR(double signal, double noise) {
		return signal / (noiseVariance + noise);
	}

	/**
	 * Tells if the incomming message signal is corrupted by another signal.
	 * 
	 * @param signal
	 *            the signal strength of the incomming message
	 * @param noise
	 *            the noise level
	 * @return returns true if the message is corrupted
	 */
	public boolean isReceivable(double signal, double noise) {
		return calcSNR(signal, noise) > receivingStartSNR;
	}

	/**
	 * Adds the noice generated by other motes, and breaks up a transmission if
	 * the noise level is too high. Also checks if the noise is low enough to
	 * hear incomming messages or not.
	 * 
	 * @param level
	 *            the level of noise
	 * @param stream
	 *            a reference to the incomming message
	 */
	protected void addNoise(double level, Object stream) {
		switch (radioState) {
		case RECEIVING:
			noiseStrength += level;
			if (isMessageCorrupted(signalStrength, noiseStrength))
				corrupted = true;
			
			break;
			
		case IDLE:
			
			// start receiving
			senderNode = (Node) stream;			
			receivedPacket = ((Mica2NodeNonCSMA)senderNode).sentPacket.clone();
			setReceptionTimestamp(receivedPacket);
			
			corrupted = false;
			signalStrength = level;
			radioState = RadioStates.RECEIVING;
			
			if(listener != null)
				listener.startedReceiving();
			
			break;

		default:
			System.out.println("Packet lost "+ this.id);
			noiseStrength += level;
			stats.incrementPacketLoss();
			break;
		}
	}

	private void setReceptionTimestamp(RadioPacket packet) {
			UInt32 timestamp = getClock().getValue();
			packet.setTimestamp(timestamp);
			timestamp  = timestamp.subtract(packet.getEventTime());
			packet.setEventTime(timestamp);
	}

	/**
	 * Removes the noise, if a transmission is over, though if the source is the
	 * sender of the message being transmitted there is some post processing
	 * accordingly, the addressed application is notified about the incomming
	 * message.
	 * 
	 * @param stream
	 *            a reference to the incomming messagethe incomming message
	 * @param level
	 *            the level of noise
	 */
	protected void removeNoise(double level, Object stream) {
		switch (radioState) {
		case RECEIVING:
			if (senderNode == stream) {
				radioState = RadioStates.IDLE;
				
				if(listener != null)
					listener.stoppedReceiving();

				if (!corrupted) {
//					System.out.println("Packet received "+ this.id);
					this.getApplication().receiveMessage(receivedPacket);
				}
				else{
					System.out.println("Corrupted");
				}

				signalStrength = 0;
				
				senderNode = null;
				receivedPacket = null;
			}
			else{
				noiseStrength -= level;
			}
			
			break;

		default:
			noiseStrength -= level;
			break;
		}
	}
	
	protected void wakeUp(){
		if(radioState == RadioStates.OFF){
			stats.on();
			radioState = RadioStates.WAKEUP;				
			wakeUpEvent.register(wakeUpTime);
		}
	}
	
	protected void startSleepTimer(int ticks){
		sleepEvent.unregister();
		sleepEvent.register(ticks);
	}
	
	protected void stopSleepTimer(){
		sleepEvent.unregister();
	}
	
	protected void sleep(){
		if(radioState == RadioStates.IDLE){
			radioState = RadioStates.OFF;
			stats.off();
		}
			
	}		
}
