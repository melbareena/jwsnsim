/*
 * Copyright (c) 2014, Ege University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the
 *   distribution.
 * - Neither the name of the copyright holder nor the names of
 *   its contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * @author KasÄ±m Sinan YILDIRIM (sinanyil81@gmail.com)
 *
 */

package hardware.transceiver;

import hardware.Register32;
import sim.configuration.TransmissionConfiguration;
import sim.node.Node;
import sim.node.NodeFactory;
import sim.node.Position;
import sim.radio.Radio;
import sim.simulator.Event;
import sim.simulator.EventObserver;

/**
 * This radio model determines a quotient q = s / (i+n) between the received
 * signal and the sum of the ambient background noise n and the interference caused
 * by all concurrent transmissions. The transmission succeeds if q > beta, where beta
 * is a small constant. 
 * 
 * This model assumes that the intensity of an electric signal decays exponentially 
 * with the distance from the sender. This decrease is parameterized by the path-loss 
 * exponent alpha: Intensity(r) = sendPower/r^alpha. The value of alpha is often chosen
 * in the range between 2 and 6.
 * 
 * To the interference caused by concurrent transmissions, we add an ambient noise 
 * level N.
 * 
 */
public class Transceiver extends Radio implements EventObserver{	
	
	/** owner node */
	protected Node node;

	/** The vector of the neighboring nodes. */
	protected Node[] neighbors; 
	
	private Node[] receivers;

	
	protected Packet packetToTransmit = null;
	protected Packet receivingPacket = null;

	/**	Signal stregth of transmitting or parent node.  */
	private double signalStrength = 0;

	/**	Noise generated by other nodes. */
	private double noiseStrength = 0;	

	/** State variable, true if the last received message got corrupted by noise */
	protected boolean   corrupted        = false;

	protected boolean receiving = false;
	protected boolean transmitting = false;

	public static int    sendTransmissionTime          = 960;
	
	private Event endTransmissionEvent = new Event(this);
	
	private TransceiverListener listener;	

	public Transceiver(Node node,TransceiverListener listener){
		this.node = node;
		this.listener= listener;
	}
	
	public void on() {		
		for(int i=0; i<NodeFactory.nodes.length;i++){
			((Transceiver)(NodeFactory.nodes[i].getRadio())).updateNeighborhood();
		}
	}

	public void updateNeighborhood() {
  
        Node[] neighbors = new Node[NodeFactory.numNodes];

        int i = 0;
        
        
        for (int j = 0; j<NodeFactory.numNodes; j++){
        	Node node1 = NodeFactory.nodes[j];
        	
        	if(node1.isRunning()){
				double distance = node.getPosition().distanceTo(node1.getPosition());
				if( distance <= TransmissionConfiguration.MAX_RANGE && node != node1){
					neighbors[i] = node1;                   
					i++;
				}				
			}
        }
        
		this.neighbors = new Node[i];
        System.arraycopy( neighbors, 0,this.neighbors, 0, i );
        
//        System.out.println("---------------------------------");
//        System.out.print(node.getID() + "'s neighbors: ");
//        for (int j = 0; j < this.neighbors.length; j++) {
//        	System.out.print(this.neighbors[j].getID() + " ");
//		}
//        System.out.println("");
//        System.out.println("---------------------------------");
        
	}
	


	public void beginTransmission(Packet packet){	
			
		packetToTransmit = packet;
		setTransmissionTimestamp();
		packet.setIntensity(intensity);
		
		transmitting = true;
		
		receivers = new Node[neighbors.length];
		System.arraycopy( neighbors, 0,receivers, 0, neighbors.length );
		
		int i = receivers.length;
		while( --i >= 0 ){
			receivers[i].getRadio().receptionBegin(packet);
		}
		
		endTransmissionEvent.register(sendTransmissionTime);
		listener.transmissionBegin();
	}

	private void setTransmissionTimestamp() {	
		Register32 age = node.getClock().getValue();
		age = age.subtract(packetToTransmit.getEventTime());
//		System.out.println("Packet age " + age.getValue());
		packetToTransmit.setEventTime(age);
	}
	
	public void endTransmission(){	
		int i = receivers.length;
		while( --i >= 0 )
			receivers[i].getRadio().receptionEnd(packetToTransmit);
		
		packetToTransmit = null;
		receivers = null;
		transmitting = false;
		listener.transmissionEnd();
	}
	
	protected double getNoise(Packet packet) {
		Position pos = packet.getSender().getPosition();
		double distance = pos.distanceTo(node.getPosition());
		double poweredDistance = Math.pow(distance, TransmissionConfiguration.alpha);
		return packet.getIntensity() / poweredDistance;
	}
	
	public void receptionBegin(Packet packet) {
		
        if(receiving){
			noiseStrength += getNoise(packet);
			
            if(isMessageCorrupted())
                corrupted = true;
        } else{
            if(!transmitting){
                // start receiving
            	receivingPacket = new Packet((Packet)packet);
            	setReceptionTimestamp();
                receiving		= true;
                corrupted     	= false;
                signalStrength 	= getNoise(packet);
                noiseStrength = TransmissionConfiguration.ambientNoise;
                
                listener.receptionBegin();
            }
            else{
                noiseStrength += getNoise(packet);
            }
        }
	}

	private void setReceptionTimestamp() {
		Register32 timestamp = node.getClock().getValue();
		receivingPacket.setTimestamp(timestamp);
//		System.out.println("Receiving age: " + receivingPacket.getEventTime().getValue());
		timestamp  = timestamp.subtract(receivingPacket.getEventTime());
		receivingPacket.setEventTime(timestamp);
	}

	/**
	 * Calls the {@link Mica2NodeNonCSMA#removeNoise} method. See also 
	 * {@link Node#receptionEnd} for more information.
	 */
	public void receptionEnd(Packet packet) {
		
		if(receivingPacket != null && receivingPacket.equals(packet)){            
            receiving = false;
            
            if(!corrupted){
            	node.getMAC().receivePacket(receivingPacket);
            }            
            else
            	System.out.println(""+ node.getID()+ " Corruption!");
            
            receivingPacket = null;
            signalStrength = 0;
            noiseStrength -= TransmissionConfiguration.ambientNoise;
            listener.receptionEnd();                        
        }
		else{
			noiseStrength -= getNoise(packet);
		}
	}
	
	public boolean isMessageCorrupted( ){
		return signalStrength < TransmissionConfiguration.beta * noiseStrength; 
	}

	@Override
	public void signal(Event event) {
		if( event == endTransmissionEvent){						
			endTransmission();
		}		
	}

	@Override
	protected boolean isChannelFree() {
		
		return true;
	}

	@Override
	public Node[] getNeighbors() {
		// TODO Auto-generated method stub
		return neighbors;
	}
}

