package sim.jprowler.radio;

import sim.jprowler.Node;
import sim.jprowler.UInt32;
import sim.jprowler.clock.Clock;

public class Radio {

	public enum RadioStates {
		OFF, IDLE, WAKEUP, PROCESSING,TRANSMITTING,RECEIVING
	}

	RadioStates radioState = RadioStates.IDLE;
	RadioProcessor radioProcessor;
	RadioListener listener;
	
	
	Node node;
	Clock radioClock;
	Neighbors neighbors;
	
	double maxRadioStrength = 100;	
	
	/** Signal strength of transmitting node. */
	double signalStrength = 0;

	/** Noise generated by other nodes. */
	double noiseStrength = 0;

	boolean corrupted = false;

	RadioPacket transmitBuffer = null;
	
	Radio senderRadio = null;
	RadioPacket receiveBuffer = null;


	public Radio(Node node,Clock clock) {
		radioProcessor = new RadioProcessor(this);
		this.radioClock = clock;
		this.node = node;
		this.neighbors = new Neighbors(node);
	}
	
	public void setListener(RadioListener listener){
		this.listener = listener;
	}
	
	public RadioStates getState() {
		return radioState;
	}
		
	public RadioPacket getTransmitBuffer(){
		return transmitBuffer;
	}
	
	public double getNoiseStrength(){
		return noiseStrength;
	}
	
	public double getMaxRadioStrength(){
		return maxRadioStrength;
	}
	
	public Node getNode(){
		return node;
	}
	
	public Neighbors getNeighbors(){
		return neighbors;
	}
	
	public boolean transmit(RadioPacket packet){
		boolean success = true;

		switch (radioState) {

		case IDLE:
			transmitBuffer = packet.clone();
			
			radioState = RadioStates.PROCESSING;
			radioProcessor.process();
			
			listener.processing(transmitBuffer);
			break;

		default:
			success = false;
			break;

		}

		return success;
	}
	
	public void processingFinished() {
		switch (radioState) {

		case PROCESSING:
			radioState = RadioStates.TRANSMITTING;
			setEventTime(transmitBuffer);
			radioProcessor.transmit();
			neighbors.startTransmission(1);
			listener.startedTransmitting(transmitBuffer);
			break;

		default:
			break;
		}
	}

	private void setEventTime(RadioPacket packet) {
		UInt32 age = radioClock.getValue();
		age = age.subtract(packet.getEventTime());
		packet.setEventTime(age);
	}

	public void transmissionFinished() {
		radioState = RadioStates.IDLE;
		neighbors.endTransmission();
		listener.stoppedTransmitting(transmitBuffer);
		transmitBuffer = null;		
	}


	protected void addNoise(double level, Radio radio) {
		switch (radioState) {
		
		case RECEIVING:
			noiseStrength += level;
			if (Noise.isMessageCorrupted(signalStrength, noiseStrength)){
				corrupted = true;
				receiveBuffer = null;
				System.out.println("Corrupted " + node.getId());
			}
				

			break;

		case IDLE:

			// start receiving
			senderRadio = radio;
			receiveBuffer = radio.getTransmitBuffer().clone();
			setReceptionTimestamp(receiveBuffer);

			corrupted = false;
			signalStrength = level;
			radioState = RadioStates.RECEIVING;

			listener.startedReceiving(receiveBuffer);

			break;

		default:
			noiseStrength += level;
			listener.packetLost(receiveBuffer);

			break;
		}
	}

	private void setReceptionTimestamp(RadioPacket packet) {
		UInt32 timestamp = radioClock.getValue();
		packet.setTimestamp(timestamp);
		timestamp = timestamp.subtract(packet.getEventTime());
		packet.setEventTime(timestamp);
	}

	protected void removeNoise(double level, Radio radio) {
				
		switch (radioState) {
		case RECEIVING:
			if (senderRadio == radio) {
				radioState = RadioStates.IDLE;
				
				listener.stoppedReceiving(receiveBuffer);
				signalStrength = 0;

				senderRadio = null;
				receiveBuffer = null;
			} else {
				noiseStrength -= level;
			}

			break;

		default:
			noiseStrength -= level;
			break;
		}
	}

	public void sleep() {
		if (radioState == RadioStates.IDLE) {
			radioState = RadioStates.OFF;
			listener.radioOff();
		}
	}

	public void wakeUp() {
		if (radioState == RadioStates.OFF) {
			radioState = RadioStates.WAKEUP;
			radioProcessor.wakeUp();
			listener.radioWokeUp();
		}
	}
	
	public void wakeUpFinished() {
		switch (radioState) {

		case WAKEUP:
			radioState = RadioStates.IDLE;

			if (transmitBuffer != null) {
				radioState = RadioStates.PROCESSING;
				radioProcessor.process();
				listener.processing(transmitBuffer);
			}

			break;

		default:
			break;
		}
	}
}
